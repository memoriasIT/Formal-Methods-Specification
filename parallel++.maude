load parallel.maude

mod EXPRESSION-INT is
    extending PARALLEL .

    vars E E’ : Expression .
    var M : Memory . 

    op _=_  : Expression Expression -> Test .
    op _>’_ : Expression Expression -> Test .
    op _!=_ : Expression Expression -> Test .
    
    eq  eval(E = E’, M) = eval(E, M) == eval(E’, M) . 
    eq  eval(E >’ E’, M) = eval(E, M) > eval(E’, M) . 
    eq  eval(E != E’, M) = eval(E,M) =/= eval(E’,M) .

endm

mod EXPRESSION-BOOL is 
    extending EXPRESSION-INT . 
    
    pr QID * (sort Qid to BQid, op qid to bqid) .
    sort BExpression . 
    subsorts BQid Bool < BExpression .

    op [_,_] : BQid Bool -> Memory .
    op _in_ : BQid Memory -> Bool? . ---- cell allocated for Q?
    op _=_  : BExpression BExpression -> Test .
    op _!=_ : BExpression BExpression -> Test .
    op eval : BExpression Memory -> Bool .

    var Q : BQid . 
    vars B B’ : Bool . 
    vars BE BE’ : BExpression .
    var M : Memory .

    eq Q in [Q, B] M = true .

    eq eval(B, M) = B .
    eq eval(Q, [Q, B] M) = B . 
   ceq eval(Q,M) = false if Q in M =/= true .

    --- EQUALS
    --- With Variables
    eq  eval(Q = B, [Q, B’] M) = B == B’ .
    ceq eval(Q = B, M) = B == false if Q in M =/= true .

    --- With Literals
    eq  eval(BE = BE’, M) = eval(BE, M) == eval(BE’, M) . 

    --- NOT EQUALS
    --- With Variables
    ceq eval(Q != B, M) = B == false if Q in M =/= false .
    eq  eval(Q != B, [Q, B’] M) = B =/= B’ .
    
    --- With Literals
    eq  eval(BE != BE’, M) = eval(BE, M) =/= eval(BE’, M) . 

endm

mod EXPRESSION++ is 
    including EXPRESSION-INT .
    including EXPRESSION-BOOL .
    --- including EXPRESSION-ARRAY .
endm

--- Aux Bool module with undefined value
mod BOOL+ is
    inc BOOL .
    sort Bool+ .
    subsort Bool+ < Bool .
    op undf : -> Bool .
endm

--- Aux Integer module with undefined value
mod INT+ is
    inc INT .
    sort Int+ .
    subsort Int+ < Int .
    op undf : -> Int .
endm

--- Defines default for Booleans
view Bool0 from DEFAULT to BOOL+ is
  sort Elt to Bool+ .
  op 0 to term undf .
endv

--- Maybe no need because there's one in prelude
--- --- Defines default for Ints
--- view Int0 from DEFAULT to INT+ is
---   sort Elt to Int+ .
---   op 0 to term undf .
--- endv

--- Defines default for Expression
view Expression from DEFAULT to EXPRESSION++ is
  sort Elt to Expression .
endv

--- Defines default for BExpression
view BExpression from DEFAULT to EXPRESSION++ is
  sort Elt to BExpression .
  op 0 to term ' .
endv

--- Instanciation of array for QID, BExpression and Expression
mod QID-EXPRESSION-ARRAY is
    extending EXPRESSION-BOOL .
    extending PARALLEL .

    --- reduce in QID-EXPRESSION-ARRAY : (insert(1, 1,insert(2, 2, insert(3, 3, empty))))['one] .
    --- reduce in QID-EXPRESSION-ARRAY : (insert(1, true,insert(2, false, insert(3, true, empty))))['one] .
    pr ARRAY{Nat, Expression} .
    pr ARRAY{Nat, BExpression} * (sort Array to BArray) .
endm

mod EXPRESSION-ARRAY is 
    extending PARALLEL .
    pr QID-EXPRESSION-ARRAY .

    pr QID * (sort Qid to AQid, op qid to aqid) .

    --- MEMORY
    --- [a, {1, 3, 5}] [b, {3, 4, 5}] - For Expression (Integers)
    --- [a, {true}] [b, {false, true, false}] - For BExpression (Booleans)
    op [_,_] : Qid Array{Nat, Expression}   -> Memory .
    op [_,_] : BQid Array{Nat, BExpression} -> Memory .

    --- EXPRESSIONS
    ---  'a[2] := 4
    ---  ['a, A] con ['a, insert(eval(4, M), eval(2, M), A)]
    sort BArray .
    subsort BArray < BExpression .
    op _[_] : BQid Expression -> BArray . --- For Bools

    --- sort ArrayIdx .
    --- subsort ArrayIdx < Expression .
    --- op _[_] : AQid Nat -> ArrayIdx [ctor] . --- For Ints

    --- op _:=_ : ArrayIdx Expression   -> Program .
    op _:=_ : BArray BExpression -> Program .

    var  M : Memory .
    var  BQ : BQid .
    var Idx : Expression .
    var B : Array{Nat, BExpression} .
    var X : Array{Nat, Expression} .
    var E : Expression .
    var  BE : BExpression .
    var I : Pid . 
    var R : Program . 
    var  S : Soup .

    --- ARRAY OF BOOLEANS
    --- Array exists, insert
    rl [BArrayInsert] : {[I, (BQ[Idx] := BE) ; R] | S, [BQ, B] M} 
      => {[I, R] | S, [BQ, insert(Idx, BE, B)] M} .

    --- Array does not exist, initialize
   crl [BArrayCreate] :  {[I, (BQ[Idx] := BE) ; R] | S, M} 
      => {[I, R] | S, [BQ, insert(Idx, BE, empty)] M} 
      if BQ in M =/= true .

    --- ARRAY OF INTEGERS
    --- rl {[I, (AQ := E) ; R] | S, [AQ, X] M} 
    ---   => {[I, R] | S, [AQ, eval(E, [AQ, X] M)] M} .

---    crl {[I, (AQ := E) ; R] | S, M} 
---       => {[I, R] | S, [AQ, eval(E, M)] M} 
---       if AQ in M =/= true .

    --- EVAL
    --- 'a[3]
    --- A[eval(3, M)]

endm

mod SEQUENTIAL++ is
    including SEQUENTIAL . 
    extending EXPRESSION++ . 

    op _:=_ : BQid BExpression -> Program .
    
endm

mod PARALLEL++ is
    inc PARALLEL . 
    inc SEQUENTIAL++ .
    inc EXPRESSION++ .
    inc EXPRESSION-ARRAY .

    var  M : Memory .
    var  BQ : BQid . 
    var B : Bool .
    var  BE : BExpression .
    var I : Pid . 
    var R : Program . 
    var  S : Soup .

    rl {[I, (BQ := BE) ; R] | S, [BQ, B] M} 
      => {[I, R] | S, [BQ, eval(BE, [BQ, B] M)] M} .

   crl {[I, (BQ := BE) ; R] | S, M} 
      => {[I, R] | S, [BQ, eval(BE, M)] M} 
      if BQ in M =/= true .


endm 

mod PRUEBAS++ is
    inc PARALLEL++ .

    op p1 : -> Program . 

    op initial : -> MachineState .
    eq initial = { [1, p1], ['turn, 1]} .
    
    eq p1
        = 
        'prueba[0] := true ;
        'prueba[2] := false ;
        'result := 2 ;
        if 'prueba[0] != true then 'result2 := 3 fi .
        
endm
